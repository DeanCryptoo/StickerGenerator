<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sticker Forge — Telegram Pack Builder</title>
<style>
  :root{
    --bg:#0f1115;--panel:#151823;--muted:#8892a6;--text:#e6e9ef;--accent:#7c3aed;--accent-2:#22d3ee;--ok:#22c55e;--warn:#f59e0b;--danger:#ef4444;
    --card:#10131c;--border:#22273a;--shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:18px;
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 800px at 10% -10%,rgba(34,211,238,.08),transparent),
        radial-gradient(900px 700px at 120% 10%,rgba(124,58,237,.09),transparent),var(--bg);color:var(--text);font:14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji"}
  h1{font-size:22px;margin:0}
  .app{display:grid;grid-template-columns:360px 1fr;min-height:100vh}
  aside{background:linear-gradient(180deg,rgba(255,255,255,.03),transparent 160px),var(--panel);border-right:1px solid var(--border);padding:18px 16px 22px;overflow:auto}
  main{padding:20px;overflow:auto}
  .brand{display:flex;align-items:center;gap:10px;margin-bottom:16px}
  .logo{width:32px;height:32px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));box-shadow:0 6px 16px rgba(124,58,237,.4)}
  .sub{color:var(--muted);font-size:12px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow)}
  .section{padding:14px 14px 12px;margin-bottom:14px}
  .section h2{font-size:13px;text-transform:uppercase;letter-spacing:.12em;color:var(--muted);margin:0 0 10px}
  .grid{display:grid;gap:10px}
  .two{grid-template-columns:1fr 1fr}
  .three{grid-template-columns:repeat(3,1fr)}
  label{display:block;font-weight:600;margin-bottom:6px}
  input[type="text"], input[type="number"], select, textarea{width:100%;background:#0b0e15;border:1px solid var(--border);color:var(--text);padding:10px 12px;border-radius:12px;outline:none}
  textarea{min-height:72px;resize:vertical}
  .muted{color:var(--muted)}
  .drop{border:1.5px dashed #2a3150;border-radius:16px;padding:16px;text-align:center;background:rgba(124,58,237,.06)}
  .drop.drag{background:rgba(34,211,238,.12);border-color:var(--accent-2)}
  .drop input{display:none}
  .btn{appearance:none;border:1px solid var(--border);background:#101423;color:var(--text);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
  .btn:hover{border-color:#334067}
  .btn.primary{background:linear-gradient(180deg,rgba(124,58,237,.25),rgba(124,58,237,.15));border-color:#3a2d7c}
  .btn.success{background:linear-gradient(180deg,rgba(34,197,94,.25),rgba(34,197,94,.1));border-color:#1f8a53}
  .btn.ghost{background:transparent}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .preview-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:14px}
  .thumb{position:relative;border-radius:14px;background:linear-gradient(180deg,rgba(255,255,255,.02),transparent),#0b0f17;border:1px solid var(--border);padding:8px;display:flex;align-items:center;justify-content:center;aspect-ratio:1/1}
  .thumb canvas{max-width:100%;max-height:100%;}
  .thumb .actions{position:absolute;bottom:8px;left:8px;right:8px;display:flex;gap:8px}
  .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);background:#0b0f17;padding:6px 8px;border-radius:999px}
  .list{display:grid;gap:6px;max-height:200px;overflow:auto}
  .list label{display:grid;grid-template-columns:auto 1fr;align-items:center;gap:8px;font-weight:500}
  .small{font-size:12px}
  .hr{height:1px;background:linear-gradient(90deg,transparent,#23283c,transparent);margin:10px 0}
  .tiny{font-size:11px}
  .flex{display:flex;gap:10px;align-items:center}
  .right{justify-content:flex-end}
  .range-wrap{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px}
  .kicker{font-size:11px;color:#9bb0ff}
  .badge{font-size:11px;background:#18223c;border:1px solid #263159;padding:3px 8px;border-radius:999px;color:#b8c4ff}
  .footer{color:var(--muted);font-size:12px;margin-top:6px}
  .hidden{display:none}
</style>
</head>
<body>
  <div class="app">
    <aside>
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>Sticker Forge</h1>
          <div class="sub">Telegram pack builder for memecoins</div>
        </div>
      </div>

      <div class="card section" id="uploadCard">
        <h2>Images</h2>
        <div id="drop" class="drop">
          <input id="fileInput" type="file" accept="image/*" multiple>
          <div><strong>Drag & drop</strong> PNGs/WebPs here (keeps transparency) or <button class="btn ghost" id="browseBtn">Browse</button></div>
          <div class="muted tiny" style="margin-top:6px">Images will be auto-fit into a 512×512 canvas (Telegram size).</div>
        </div>
        <div id="fileList" class="footer">No files yet.</div>
      </div>

      <div class="card section">
        <h2>Text presets</h2>
        <div class="grid">
          <div class="two">
            <div>
              <label for="token">Token / Ticker</label>
              <input id="token" type="text" placeholder="e.g. BG, BEASTLAB" />
              <div class="tiny muted">Used in presets as <span class="badge">{TOKEN}</span></div>
            </div>
            <div>
              <label for="style">Caption style</label>
              <select id="style">
                <option value="top">Top caption</option>
                <option value="bottom">Bottom caption</option>
                <option value="both" selected>Top & bottom</option>
                <option value="none">No text</option>
              </select>
            </div>
          </div>

          <div class="list" id="presetList"></div>
          <details>
            <summary class="small">Custom list (comma-separated)</summary>
            <textarea id="customList" placeholder="Type phrases separated by commas…"></textarea>
          </details>
        </div>
      </div>

      <div class="card section">
        <h2>Typography</h2>
        <div class="grid">
          <div class="two">
            <div>
              <label for="fontFamily">Font family</label>
              <select id="fontFamily">
                <option>Impact, Haettenschweiler, 'Arial Black', sans-serif</option>
                <option>Arial Black, Arial, sans-serif</option>
                <option>Segoe UI, Roboto, Helvetica, Arial</option>
                <option>Inter, Segoe UI, Roboto, Arial</option>
                <option>System UI, -apple-system, Segoe UI</option>
              </select>
            </div>
            <div>
              <label for="letterCase">Letter case</label>
              <select id="letterCase">
                <option value="upper" selected>UPPERCASE</option>
                <option value="title">Title Case</option>
                <option value="lower">lowercase</option>
              </select>
            </div>
          </div>
          <div class="two">
            <div class="range-wrap">
              <label for="fontSize">Font size</label>
              <input id="fontSize" type="range" min="18" max="96" value="48"/>
              <span id="fontSizeVal" class="tiny muted">48</span>
            </div>
            <div class="range-wrap">
              <label for="stroke">Outline</label>
              <input id="stroke" type="range" min="0" max="12" value="6"/>
              <span id="strokeVal" class="tiny muted">6</span>
            </div>
          </div>
          <div class="two">
            <div class="range-wrap">
              <label for="padding">Padding</label>
              <input id="padding" type="range" min="0" max="60" value="24"/>
              <span id="paddingVal" class="tiny muted">24</span>
            </div>
            <div class="range-wrap">
              <label for="lineHeight">Line height</label>
              <input id="lineHeight" type="range" min="1" max="1.6" step="0.05" value="1.1"/>
              <span id="lineHeightVal" class="tiny muted">1.10</span>
            </div>
          </div>
          <div class="two">
            <div>
              <label for="fill">Text color</label>
              <input id="fill" type="color" value="#ffffff"/>
            </div>
            <div>
              <label for="outline">Outline color</label>
              <input id="outline" type="color" value="#000000"/>
            </div>
          </div>
          <div class="two">
            <div class="flex">
              <input id="shadow" type="checkbox" checked />
              <label for="shadow" style="margin:0">Soft shadow</label>
            </div>
            <div class="flex">
              <input id="watermark" type="checkbox" />
              <label for="watermark" style="margin:0">Tiny watermark</label>
            </div>
          </div>
        </div>
      </div>

      <div class="card section">
        <div class="toolbar right">
          <button class="btn" id="clearBtn">Clear</button>
          <button class="btn primary" id="renderBtn">Render Stickers</button>
          <button class="btn success" id="exportBtn">Export All</button>
        </div>
        <div class="footer">Exports as transparent <strong>PNG 512×512</strong> files. Telegram recommends &lt; 512KB per sticker.</div>
      </div>

      <div class="footer">Pro tip: Use transparent PNGs for characters; captions stay crisp on any background.</div>
    </aside>

    <main>
      <div class="card section">
        <div class="flex" style="justify-content:space-between;align-items:end">
          <div>
            <div class="kicker">Preview</div>
            <h1 style="font-size:18px;margin-top:6px">Your Sticker Set</h1>
          </div>
          <div class="pill"><span id="count">0</span> generated</div>
        </div>
        <div class="hr"></div>
        <div id="grid" class="preview-grid"></div>
      </div>
    </main>
  </div>

<script>
(function(){
  const MAX = 512; // Telegram sticker canvas
  const state = {
    images: [], // {name, img}
    canvases: [],
  };

  // Elements
  const drop = document.getElementById('drop');
  const fileInput = document.getElementById('fileInput');
  const browseBtn = document.getElementById('browseBtn');
  const fileList = document.getElementById('fileList');
  const presetList = document.getElementById('presetList');
  const grid = document.getElementById('grid');
  const count = document.getElementById('count');

  const tokenEl = document.getElementById('token');
  const styleEl = document.getElementById('style');
  const fontFamilyEl = document.getElementById('fontFamily');
  const letterCaseEl = document.getElementById('letterCase');
  const fontSizeEl = document.getElementById('fontSize');
  const strokeEl = document.getElementById('stroke');
  const paddingEl = document.getElementById('padding');
  const lineHeightEl = document.getElementById('lineHeight');
  const fillEl = document.getElementById('fill');
  const outlineEl = document.getElementById('outline');
  const shadowEl = document.getElementById('shadow');
  const watermarkEl = document.getElementById('watermark');
  const customListEl = document.getElementById('customList');

  const renderBtn = document.getElementById('renderBtn');
  const exportBtn = document.getElementById('exportBtn');
  const clearBtn = document.getElementById('clearBtn');

  // Preset phrases tailored for memecoin culture
  const PRESETS = [
    'WAGMI', 'Only Up', 'Send It', 'Ape In', 'No FUD', 'No Spam!', 'Welcome!', 'Lock In', 'Key Figures', 'Live from {TOKEN}',
    'GM {TOKEN} Army', 'GN {TOKEN} Fam', 'When Moon?', 'New ATH', 'Buy the Dip', 'Diamond Hands', 'Just Chill', 'We Moon Soon',
    'Aped!', 'Zero to Hero', 'Born to {TOKEN}', 'Walk between the drops', 'Good night Honey', 'Good morning Ser', 'No Rug',
    "Let's fucking go", 'Print Green', 'Charts Only Up', 'Dev Update', 'Community Call', 'Hodl!!!'
  ];

  // Build preset checklist
  function buildPresets(){
    presetList.innerHTML = '';
    PRESETS.forEach((p, i)=>{
      const id = 'p_'+i;
      const row = document.createElement('label');
      row.innerHTML = `<input type="checkbox" id="${id}" checked> <span>${escapeHtml(p)}</span>`;
      presetList.appendChild(row);
    });
  }

  function escapeHtml(str){
    return str.replace(/[&<>\"]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[s]));
  }

  // File handling
  ['dragenter','dragover'].forEach(evt=>drop.addEventListener(evt, e=>{e.preventDefault();drop.classList.add('drag');}));
  ;['dragleave','drop'].forEach(evt=>drop.addEventListener(evt, e=>{e.preventDefault();drop.classList.remove('drag');}));
  drop.addEventListener('drop', (e)=> handleFiles(e.dataTransfer.files));
  browseBtn.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', ()=> handleFiles(fileInput.files));

  function handleFiles(files){
    const list = Array.from(files).filter(f=>/^image\//.test(f.type));
    if(!list.length) return;
    let loaded = 0;
    list.forEach(file=>{
      const img = new Image();
      img.onload = ()=>{
        state.images.push({name: file.name.replace(/\.[^.]+$/, ''), img});
        loaded++;
        if(loaded===list.length) updateFileList();
      };
      img.onerror = ()=> console.warn('Failed to load', file.name);
      img.src = URL.createObjectURL(file);
    });
  }

  function updateFileList(){
    if(!state.images.length){fileList.textContent='No files yet.';return;}
    fileList.innerHTML = state.images.map((f,i)=>`<span class="badge">${i+1}</span> ${escapeHtml(f.name)}`).join('<br/>');
  }

  // Sticker rendering
  function normalizeCase(s){
    const mode = letterCaseEl.value;
    if(mode==='upper') return s.toUpperCase();
    if(mode==='lower') return s.toLowerCase();
    // Title Case
    return s.replace(/\w\S*/g, w=>w[0].toUpperCase()+w.slice(1).toLowerCase());
  }

  function compilePhrases(){
    const token = tokenEl.value.trim() || '{TOKEN}';
    const chosen = PRESETS.filter((_,i)=> document.getElementById('p_'+i).checked);
    const customs = (customListEl.value||'').split(',').map(s=>s.trim()).filter(Boolean);
    return [...chosen, ...customs].map(s=> s.replaceAll('{TOKEN}', token));
  }

  function fitAndCenter(ctx, img){
    const W = MAX, H = MAX;
    const scale = Math.min(W / img.width, H / img.height);
    const w = img.width * scale;
    const h = img.height * scale;
    const x = (W - w)/2, y = (H - h)/2;
    ctx.drawImage(img, x, y, w, h);
  }

  function wrapLines(ctx, text, maxWidth){
    const words = text.split(' ');
    const lines = [];
    let line = '';
    for(const word of words){
      const test = line ? line + ' ' + word : word;
      if(ctx.measureText(test).width > maxWidth && line){
        lines.push(line); line = word;
      }else{ line = test; }
    }
    if(line) lines.push(line);
    return lines;
  }

  function drawCaption(ctx, text, position){
    if(!text) return;
    const pad = +paddingEl.value;
    const size = +fontSizeEl.value;
    const stroke = +strokeEl.value;
    const lh = +lineHeightEl.value;
    ctx.save();
    ctx.font = `700 ${size}px ${fontFamilyEl.value}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = fillEl.value;
    ctx.lineWidth = stroke * 2; // canvas stroke is centered
    ctx.strokeStyle = outlineEl.value;
    if(shadowEl.checked){
      ctx.shadowColor = 'rgba(0,0,0,.35)';
      ctx.shadowBlur = Math.max(8, size/6);
      ctx.shadowOffsetY = Math.max(2, size/12);
    }
    const maxWidth = MAX - pad*2;
    const lines = wrapLines(ctx, text, maxWidth);
    const totalHeight = lines.length * size * lh;
    let y; const x = MAX/2;
    if(position==='top'){
      y = pad + size; // top baseline for first line
    } else {
      y = MAX - pad - (totalHeight - size*0.2); // bottom block
    }
    for(const line of lines){
      if(stroke>0) ctx.strokeText(line, x, y);
      ctx.fillText(line, x, y);
      y += size * lh;
    }
    ctx.restore();
  }

  function drawWatermark(ctx){
    if(!watermarkEl.checked) return;
    ctx.save();
    ctx.font = `600 12px ${fontFamilyEl.value}`;
    ctx.fillStyle = 'rgba(255,255,255,.65)';
    ctx.strokeStyle = 'rgba(0,0,0,.55)';
    ctx.lineWidth = 2;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    const text = 'Sticker Forge';
    ctx.strokeText(text, MAX-8, MAX-6);
    ctx.fillText(text, MAX-8, MAX-6);
    ctx.restore();
  }

  function makeCanvas(){
    const c = document.createElement('canvas');
    c.width = MAX; c.height = MAX;
    return c;
  }

  function clearGrid(){
    grid.innerHTML = '';
    state.canvases = [];
    count.textContent = '0';
  }

  function render(){
    if(!state.images.length){alert('Upload at least one image first.');return;}
    clearGrid();
    const phrases = styleEl.value==='none' ? [''] : compilePhrases();

    state.images.forEach((file)=>{
      phrases.forEach((phrase)=>{
        const topText = (styleEl.value==='top' || styleEl.value==='both') ? normalizeCase(phrase) : '';
        const bottomText = (styleEl.value==='bottom' || styleEl.value==='both') ? normalizeCase(phrase) : '';
        const c = makeCanvas();
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,MAX,MAX);
        fitAndCenter(ctx, file.img);
        // captions on top of image
        drawCaption(ctx, topText, 'top');
        drawCaption(ctx, bottomText, 'bottom');
        drawWatermark(ctx);
        addThumb(c, `${file.name}__${phrase || 'plain'}`);
      });
    });
    count.textContent = state.canvases.length;
  }

  function addThumb(canvas, baseName){
    const wrap = document.createElement('div');
    wrap.className = 'thumb';
    const actions = document.createElement('div');
    actions.className = 'actions';
    const a = document.createElement('a');
    a.className = 'btn';
    a.textContent = 'PNG';
    a.download = sanitize(baseName)+'.png';
    a.href = canvas.toDataURL('image/png');
    actions.appendChild(a);

    const copyBtn = document.createElement('button');
    copyBtn.className = 'btn';
    copyBtn.textContent = 'Copy';
    copyBtn.addEventListener('click', async ()=>{
      canvas.toBlob(async (blob)=>{
        try{
          await navigator.clipboard.write([new ClipboardItem({'image/png': blob})]);
          copyBtn.textContent = 'Copied!';
          setTimeout(()=>copyBtn.textContent='Copy',1200);
        }catch(err){
          alert('Clipboard not supported: '+err);
        }
      }, 'image/png');
    });
    actions.appendChild(copyBtn);

    wrap.appendChild(canvas);
    wrap.appendChild(actions);
    grid.appendChild(wrap);
    state.canvases.push({canvas, name: a.download});
  }

  function sanitize(s){
    return s.replace(/[^a-z0-9_\-]+/gi,'_').slice(0,80);
  }

  // Export all by triggering sequential downloads
  async function exportAll(){
    if(!state.canvases.length){alert('Nothing to export. Render stickers first.');return;}
    for(const {canvas, name} of state.canvases){
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url; a.download = name; document.body.appendChild(a); a.click(); a.remove();
      await new Promise(r=>setTimeout(r, 150)); // throttle
    }
  }

  // Controls live labels
  function connectRange(id, out){
    const el = document.getElementById(id), label = document.getElementById(out);
    const sync = ()=> label.textContent = (id==='lineHeight' ? parseFloat(el.value).toFixed(2) : el.value);
    el.addEventListener('input', sync); sync();
  }

  connectRange('fontSize','fontSizeVal');
  connectRange('stroke','strokeVal');
  connectRange('padding','paddingVal');
  connectRange('lineHeight','lineHeightVal');

  // Actions
  renderBtn.addEventListener('click', render);
  exportBtn.addEventListener('click', exportAll);
  clearBtn.addEventListener('click', ()=>{state.images=[];updateFileList();clearGrid();});

  buildPresets();
})();
</script>
</body>
</html>
